// ============================================================================
// 
// Copyright (c) 2003-2014 Barco N.V.
// 
// ============================================================================
// 
// This file is part of "BFC".
// 
// "BFC" is free software; you can redistribute it and/or modify it
// under the terms of the GNU Lesser General Public License as published
// by the Free Software Foundation; either version 2.1 of the License, or
// (at your option) any later version.
// 
// "BFC" is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public License
// along with "BFC"; if not, write to:
//                          Free Software Foundation
//                          59 Temple Place, Suite 330
//                          Boston, MA 02111-1307 USA
// 
// ============================================================================
// 
// Filename:
//	BFC.Crypto.HMAC.cpp
// 
// Description:
//	...
// 
// Author(s):
//	Jean-Francois GOBBERS
// 
// ============================================================================

#include "BFC.Crypto.HMAC.h"
#include "BFC.Crypto.HashRepository.h"
#include "BFC.Crypto.MACRegisterer.h"

// ============================================================================

using namespace BFC;

// ============================================================================

BFC_PTR_IMPL_NS( Crypto, HMAC )

// ============================================================================

const DL::TypeCPtr & Crypto::HMAC::getClassType() {

	static DL::TypeCPtr i = new DL::Type(
		UUId( "0204f7bb-8311-48f7-8553-c3d1390fc7ee" ),
		"BFC.Crypto.HMAC",
		Crypto::MAC::getClassType(),
		new DL::Descr(
			"hmac",
			"MAC",
			"HMAC MAC" ) );

	return i;

}

// ============================================================================

Crypto::HMAC::HMAC() :

	MAC( getClassType() ) {

}

// ============================================================================

void Crypto::HMAC::init(
		HashPtr		pHash,
	const	Buffer &	pKey ) {

	usrHash	= pHash;
	hshSize	= usrHash->getHashSize();
	blkSize	= usrHash->getBlockSize();

	if ( pKey.getLength() > blkSize ) {
		usrHash->hashMemory( pKey, key );
	}
	else {
		key = pKey;
	}

	if ( key.getLength() < blkSize ) {
		key.pad( blkSize );
	}

	Buffer	buf;

	buf.resize( blkSize );

	const Uchar *	src = key.getCstPtr();
	Uchar *		dst = buf.getVarPtr();

	for ( Uint32 i = 0 ; i < blkSize ; i++ ) {
		dst[ i ] = src[ i ] ^ 0x36;
	}

	usrHash->init();
	usrHash->process( buf );
 
}

void Crypto::HMAC::process(
	const	Buffer &	pData ) {

	usrHash->process( pData );

}

void Crypto::HMAC::done(
		Buffer &	pTag ) {

	Buffer	sha;

	usrHash->done( sha );

	Buffer	buf;

	buf.resize( blkSize );

	const Uchar *	src = key.getCstPtr();
	Uchar *		dst = buf.getVarPtr();

	for ( Uint32 i = 0 ; i < blkSize ; i++ ) {
		dst[ i ] = src[ i ] ^ 0x5C;
	}

	usrHash->init();
	usrHash->process( buf );
	usrHash->process( sha );
	usrHash->done( pTag );

}

// ============================================================================

void Crypto::HMAC::test() {

	static const struct {
		Uint32		num;
		const Char *	algo;
		Uchar		key[128];
		Uint32		keylen;
		Uchar		data[128];
		Uint32		datalen;
		Uchar		digest[128];
	} cases[] = {
		{ 5, "sha1",
				{0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
				0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
				0x0c, 0x0c, 0x0c, 0x0c}, 20,
				"Test With Truncation", 20,
				{0x4c, 0x1a, 0x03, 0x42, 0x4b, 0x55, 0xe0, 0x7f, 0xe7, 0xf2,
				0x7b, 0xe1, 0xd5, 0x8b, 0xb9, 0x32, 0x4a, 0x9a, 0x5a, 0x04}
		},
		{ 6, "sha1",
				{0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa}, 80,
				"Test Using Larger Than Block-Size Key - Hash Key First", 54,
				{0xaa, 0x4a, 0xe5, 0xe1, 0x52, 0x72, 0xd0, 0x0e,
				0x95, 0x70, 0x56, 0x37, 0xce, 0x8a, 0x3b, 0x55, 
				0xed, 0x40, 0x21, 0x12}
		},
		{ 7, "sha1",
				{0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa}, 80,
				"Test Using Larger Than Block-Size Key and Larger Than One Block-Size Data", 73,
				{0xe8, 0xe9, 0x9d, 0x0f, 0x45, 0x23, 0x7d, 0x78, 0x6d,
				0x6b, 0xba, 0xa7, 0x96, 0x5c, 0x78, 0x08, 0xbb, 0xff, 0x1a, 0x91}
		},
		{ 1, "md5",
				{0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
				0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b}, 16,
				"Hi There", 8,
				{0x92, 0x94, 0x72, 0x7a, 0x36, 0x38, 0xbb, 0x1c, 
				0x13, 0xf4, 0x8e, 0xf8, 0x15, 0x8b, 0xfc, 0x9d}
		},
		{ 2, "md5",
				"Jefe", 4,
				"what do ya want for nothing?", 28,
				{0x75, 0x0c, 0x78, 0x3e, 0x6a, 0xb0, 0xb5, 0x03, 
				0xea, 0xa8, 0x6e, 0x31, 0x0a, 0x5d, 0xb7, 0x38}
		},
		{ 3, "md5",
				{0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa}, 16,
				{0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
				0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
				0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
				0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
				0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd}, 50,
				{0x56, 0xbe, 0x34, 0x52, 0x1d, 0x14, 0x4c, 0x88,
				0xdb, 0xb8, 0xc7, 0x33, 0xf0, 0xe8, 0xb3, 0xf6}
		},
		{ 4, "md5",
				{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
				0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14,
				0x15, 0x16, 0x17, 0x18, 0x19}, 25,
				{0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
				0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
				0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
				0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
				0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd}, 50,
				{0x69, 0x7e, 0xaf, 0x0a, 0xca, 0x3a, 0x3a, 0xea, 
				0x3a, 0x75, 0x16, 0x47, 0x46, 0xff, 0xaa, 0x79}
		},
		{ 5, "md5",
				{0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
				0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c}, 16,
				"Test With Truncation", 20,
				{0x56, 0x46, 0x1e, 0xf2, 0x34, 0x2e, 0xdc, 0x00, 
				0xf9, 0xba, 0xb9, 0x95, 0x69, 0x0e, 0xfd, 0x4c}
		},
		{ 6, "md5",
				{0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
				
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa}, 80,
				"Test Using Larger Than Block-Size Key - Hash Key First", 54,
				{0x6b, 0x1a, 0xb7, 0xfe, 0x4b, 0xd7, 0xbf, 0x8f, 
				0x0b, 0x62, 0xe6, 0xce, 0x61, 0xb9, 0xd0, 0xcd}
		},
		{ 7, "md5",
				{0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa}, 80,
				"Test Using Larger Than Block-Size Key and Larger Than One Block-Size Data", 73,
				{0x6f, 0x63, 0x0f, 0xad, 0x67, 0xcd, 0xa0, 0xee,
				0x1f, 0xb1, 0xf5, 0x62, 0xdb, 0x3a, 0xa5, 0x3e}
		}
	};

	for ( Uint32 i = 0 ; i < (sizeof(cases) / sizeof(cases[0])) ; i++ ) {
		HashPtr hash = HashRepository::instance()->getNew( cases[i].algo );
		Buffer tag;
		init( hash, Buffer( cases[i].key, cases[i].keylen ) );
		process( Buffer( cases[i].data, cases[i].datalen ) );
		done( tag );
		if ( tag != Buffer( cases[ i ].digest, hash->getHashSize() ) ) {
			throw InternalError();
		}
	}

}

// ============================================================================

static Crypto::MACRegisterer< Crypto::HMAC > hmacRegisterer;

// ============================================================================

