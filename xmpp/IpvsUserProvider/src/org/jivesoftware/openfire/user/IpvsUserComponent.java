package org.jivesoftware.openfire.user;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import org.jivesoftware.openfire.IQResultListener;
import org.jivesoftware.openfire.PacketException;
import org.jivesoftware.openfire.PacketRouter;
import org.jivesoftware.openfire.RoutableChannelHandler;
import org.jivesoftware.openfire.RoutingTable;
import org.jivesoftware.openfire.XMPPServer;
import org.jivesoftware.openfire.auth.UnauthorizedException;
import org.jivesoftware.util.JiveGlobals;
import org.jivesoftware.util.Log;
import org.xmpp.packet.IQ;
import org.xmpp.packet.JID;
import org.xmpp.packet.Packet;
import org.xmpp.packet.Presence;

/**
 * @author pravin reddy
 * Email: pravin@ipvideosys.com
 * IP Video Systems , CA, USA
 * http://www.ipvideosys.com 
 * @since 1.0.0
 */
public class IpvsUserComponent implements RoutableChannelHandler { // , ComponentEventListener{
    private JID jid = null;
    private String dbcomponent = "";
    private JID dbcomponentJID = null;
    //private PresenceManager presenceManager;

    private String serviceName = null;
    private IpvsUserProvider provider = null;
    private RoutingTable routingTable = null;
    private PacketRouter router = null;
    private Map<String, IQResultListenerImpl> resultListeners = new ConcurrentHashMap<String, IQResultListenerImpl>();
    private Map<String, Long> resultTimeout = new ConcurrentHashMap<String, Long>();
    private ThreadPoolExecutor threadPool;

    public IpvsUserComponent(IpvsUserProvider provider) {
        this.provider = provider;
        /*
        ipvs.db.component.jid.prefix=ipvsdbservice
        ipvs.openfire.user.component.jid.prefix=ipvsuserauthservice          
         */
        serviceName = JiveGlobals.getProperty("ipvs.component.user.name", "ipvsuserauthservice");

        routingTable = XMPPServer.getInstance().getRoutingTable();
        router = XMPPServer.getInstance().getPacketRouter();

        jid = getAddress();
        routingTable.addComponentRoute(jid, this);
        int maxThreads = 20;
        threadPool = new ThreadPoolExecutor(maxThreads, maxThreads, 1, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new ThreadPoolExecutor.CallerRunsPolicy());
        //presenceManager = XMPPServer.getInstance().getPresenceManager();
        //InternalComponentManager componentManager=null;
        //componentManager.addPresenceRequest(prober, probee)
        //ExternalComponentManager.addListener(listener)
        //XMPPServer.getInstance().getComponentManager().addListener(this);
        //InternalComponentManager.getInstance().addListener(this);
    }

    public void setDbcomponent(String dbcomponent) {
        this.dbcomponent = dbcomponent;
        dbcomponentJID = new JID(dbcomponent);
        MRDebug.log("dbcomponent " + this.dbcomponent + " " + dbcomponentJID.toString());
    }

    public String getServiceDomain() {
        return serviceName + "." + XMPPServer.getInstance().getServerInfo().getXMPPDomain();
    }

    public JID getAddress() {
        if (jid == null)
            jid = new JID(null, getServiceDomain(), null);
        return jid;
    }

    void addIQResultListener(String id, IQResultListenerImpl listener, long timeoutmillis) {
        // be generated by the server and simulate like the client sent it. This will let listeners
        // react and be removed from the collection
        resultListeners.put(id, listener);
        resultTimeout.put(id, System.currentTimeMillis() + timeoutmillis);
    }

    /*public boolean isComponentPresence(){
        //presenceManager.probePresence(getAddress(), dbcomponentJID);
    }*/
    public String subscribeToPresence(String jid, String to, long timeout) {
        Presence packet = new Presence(Presence.Type.subscribe);
        packet.setTo(to);
        packet.setFrom(getAddress());
        router.route(packet);
        //MRDebug.log("subscribeToPresence " + packet.toXML());
        return "";
    }

    public IQ query(IQ packet, String userQuery, long timeout) throws Exception {
        final LinkedBlockingQueue<Packet> answer = new LinkedBlockingQueue<Packet>(8);
        IQResultListenerImpl iqResultListenerImpl = new IQResultListenerImpl(answer, userQuery);
        addIQResultListener(packet.getID(), iqResultListenerImpl, timeout);
        //MRDebug.log("--------- sent " + packet.getID() +" query='" +iqResultListenerImpl.getUserQuery() + "'" );
        //MRDebug.log();
        router.route(packet);
        IQ reply = null;
        try {
            Packet reply2 = answer.poll(timeout, TimeUnit.MILLISECONDS);
            if(reply2==null) {
                MRDebug.log("--------- TIME OUT ANSWER query='" +iqResultListenerImpl.getUserQuery() + "'" );
                throw new Exception("ERROR: Request timed out. packet- " +" " + packet.toXML());
            }
            if (reply2 instanceof IQ) {
                //MRDebug.log("--------- GOT ANSWER query='" +iqResultListenerImpl.getUserQuery() + "'" );
                reply = (IQ) reply2;
            }  
        } catch (InterruptedException e) {
            // Ignore
        } finally {
            resultTimeout.remove(packet.getID());
            resultListeners.remove(packet.getID());
        }
        return reply;
    }

    public void gotIQResp() {
        //Document doc =null; 
    }

    public void process(final Packet packet) throws UnauthorizedException, PacketException {
        threadPool.execute(new Runnable() {
            public void run() {
                try {
                    if (packet instanceof IQ) {
                        IQ iq = (IQ) packet;
                        IQ.Type iqType = iq.getType();
                        if (IQ.Type.result == iqType || IQ.Type.error == iqType) {
                            // The server got an answer to an IQ packet that was sent from the component
                            IQResultListenerImpl iqResultListener = resultListeners.remove(iq.getID());
                            if (iqResultListener != null) {
                                try {
                                    //MRDebug.log("--------- got " + packet.getID() +" query='" +iqResultListener.getUserQuery() + "'" );
                                    iqResultListener.receivedAnswer(iq);
                                } catch (Exception e) {
                                    Log.error("Error processing answer of remote entity", e);
                                }
                                return;
                            } else {
                                //MRDebug.log("--------- got " + packet.getID() +" TIME OUT ANSWER" );
                            }
                        }
                    }
                    provider.processNotifications(packet);
                } finally {
                    //MRDebug.log("got Done " + packet.getID() );
                }
            }
        });
    }

    /*@Override
    public void componentInfoReceived(IQ iq) {
        System.out.println(" componentInfoReceived " + iq.toXML());
    }
    @Override
    public void componentRegistered(JID componentJID) {
        System.out.println(" componentRegistered " + componentJID.toString());
    }
    @Override
    public void componentUnregistered(JID componentJID) {
        System.out.println(" componentUnregistered " + componentJID.toString());
    }*/
    private static class IQResultListenerImpl implements IQResultListener {
        String userQuery = "";
        LinkedBlockingQueue<Packet> answer = null;

        public IQResultListenerImpl(LinkedBlockingQueue<Packet> answer, String userQuery) {
            this.answer = answer;
            this.userQuery = userQuery;
        }

        public void receivedAnswer(IQ packet) {
            //MRDebug.log("receivedAnswer "+ packet.getID() );
            answer.offer(packet);
        }

        public void answerTimeout(String packetId) {
            //Do nothing
        }

        public String getUserQuery() {

            return userQuery;
        }

        public void setUserQuery(String userQuery) {
            this.userQuery = userQuery;
        }
    }

}
