#ifndef _PTP_DOMAIN_H_
#define _PTP_DOMAIN_H_

// System headers
#include <stdint.h>
#include <string>
#include <vector>

// Library headers
#include "EthernetDefinitions.h"
#include "EventHandler.h"
#include "Lockable.h"
#include "NetlinkClient.h"
#include "PtpEvent.h"

// IEEE 802.1AS PTP profile properties
#define IEEE_802_1_AS_DOMAIN_NUMBER          (     0)
#define IEEE_802_1_AS_GRANDMASTER_PRIORITY1  (   248)
#define IEEE_802_1_AS_GRANDMASTER_PRIORITY2  (   248)
#define IEEE_802_1_AS_CLOCK_CLASS            (   248)
#define IEEE_802_1_AS_CLOCK_ACCURACY         (  0xFE)
#define IEEE_802_1_AS_SCALED_LOG_VARIANCE    (0x4100)
#define IEEE_802_1_AS_UTC_OFFSET             (    33)

// Locate within the "Avb" namespace
namespace Avb {
  
  /**
   * Class forward references
   */
  class AvbPort;

  /**
   * Wrapper class for the Lab X PTP hardware.  This encapsulates device driver calls
   * and clock / PTP profile configuration behind a high-level interface.
   *
   * Copyright (c) 2010 Lab X Technologies.  All rights reserved.
   * @author Eldridge M. Mount IV
   */
  class PtpDomain : public LabX::Lockable {

    // Public type definitions
  public:

    /**
     * Enumerated type for delay mechanism
     */
    typedef enum {
      DELAY_MECHANISM_E2E,
      DELAY_MECHANISM_P2P,
    } DelayMechanism;

    /**
     * Constructor / Destructor
     */
  public:
    
    /**
     * Creates an instance associated with the passed device and using the passed
     * source MAC address for all packets.
     * @param domainName - PTP domain name
     * @param deviceName - Device name, e.g. "/dev/ptp0"
     * @param avbPorts   - AVB ports associated with each PTP port
     */
    PtpDomain(const std::string &domainName, 
              const std::string &deviceName,
              const std::vector<AvbPort*> &avbPorts);

    /**
     * Virtual destructor
     */
    virtual ~PtpDomain(void);
    
    // Public interface methods
  public:

    /**
     * Returns the domain name
     * @return - Name of the PTP domain
     */
    const std::string& getDomainName(void) const;
    
    /**
     * Opens the instance with the passed configuration parameters and starts
     * the PTP service.  All of the clock quality / priority parameters have
     * appropriate defaults defined in this file for use in an 802.1AS domain.
     * @param currentUtcOffset     - Current offset from UTC
     * @param grandmasterPriority1 - Grandmaster priority 1
     * @param grandmasterPriority2 - Grandmaster priority 2
     * @param clockClass           - Clock class
     * @param clockAccuracy        - Clock accuracy
     * @param offsetLogVariance    - Offset log variance
     * @param delayMechanism       - PTP delay mechanism to be employed
     */
    virtual void open(int16_t currentUtcOffset,
                      uint8_t grandmasterPriority1,
                      uint8_t grandmasterPriority2,
                      uint8_t clockClass,
                      uint8_t clockAccuracy,
                      uint16_t offsetLogVariance,
                      DelayMechanism delayMechanism);
    
    /**
     * Closes the instance
     */
    virtual void close(void);

    /**
     * Sets the coefficients used in the RTC synchronization loop
     * @param pCoefficient - Proportional coefficient
     * @param iCoefficient - Integral coefficient
     * @param dCoefficient - Derivative coefficient
     */
    void setCoefficients(int32_t pCoefficient, int32_t iCoefficient, int32_t dCoefficient);

    /**
     * Enables or disables the service
     * @param serviceEnabled - True if the service is to be enabled, false if not
     */
    void enableService(bool serviceEnabled);

  #ifdef INCLUDE_DEBUG_INFO
    /**
     * Dump debug information about the PTP domain.
     * @param stream - stream to output debug info on
     */
    virtual void dumpDebugInfo(std::ostream& stream);
  #endif

    /**
     * Registers the passed event handler for all events generated by the instance
     * @param handler - Pointer to the handler to be registered
     */
    void registerHandler(LabX::EventHandler *handler);

    /**
     * Handles the passed PTP event instance from the Netlink handler
     * @param ptpEvent - Pointer to the event instance
     */
    void handlePtpEvent(PtpEvent &ptpEvent);

    // Private inner classes
  private:

    /**
     * Netlink client for all the domains, allowing the instances to inform
     * observers and govern when the hardware is permitted to slew its RTC
     */
    class PtpNetlink : public LabX::NetlinkClient {
      // Destructor
    public:

      /**
       * Destroys the instance
       */
      virtual ~PtpNetlink(void);

      // Public interface methods
    public:

      /**
       * Creates / returns the Singleton instance
       */
      static PtpNetlink& instance(void);

      /**
       * Registers the passed PTP domain to receive events from the driver
       * @param domainNumber - PTP domain number
       * @param ptpDomain    - Domain instance
       */
      void registerDomain(uint8_t domainNumber, PtpDomain *ptpDomain);

      // Protected overrides from class NetlinkClient
    protected:

      /**
       * Handler for messages directed to the family
       * @param nlh            - Pointer to the Netlink header of the message
       * @param multicastGroup - Name of the multicast group, if any
       */
      virtual void handleFamilyMessage(struct ::nlmsghdr *nlh, 
                                       const std::string& multicastGroup);

      // Private constructor
    private:

      /**
       * Creates an instance
       */
      PtpNetlink(void);

      // Private attributes
    private:

      /**
       * Map of PTP domain numbers to their instances
       */
      std::map<uint8_t, PtpDomain*> domainMap;

      /**
       * Pointer to the Singleton instance
       */
      static PtpNetlink *singleton;
    };

    // Private helper methods
  private:

    /**
     * Sends an I/O control command to the encapsulated device
     * @param ioCommand - Enumerated command understood by the device driver
     * @param ioParameter - Command-specific parameter data
     */
    void deviceIoControl(uint32_t ioCommand, void *ioParameter);
    
    // Private attributes
  private:

    /**
     * Domain name
     */
    const std::string domainName;
    
    /**
     * Device driver interface
     */
    const std::string deviceName;
    FILE *deviceFile;
    int32_t deviceHandle;

    /**
     * Vector of AVB ports associated with the domain
     */
    const std::vector<AvbPort*> avbPorts;

    /**
     * Collection of event handlers to notify
     */
    std::vector<LabX::EventHandler*> eventHandlers;
  };
}

#endif
